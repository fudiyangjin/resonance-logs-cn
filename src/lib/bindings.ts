
// This file was generated by [tauri-specta](https://github.com/oscartbeaumont/tauri-specta). Do not edit this file manually.

/** user-defined commands **/


export const commands = {
/**
 * Enables blur on the live meter window.
 * 
 * # Arguments
 * 
 * * `app` - A handle to the Tauri application instance.
 */
async enableBlur() : Promise<void> {
    await TAURI_INVOKE("enable_blur");
},
/**
 * Disables blur on the live meter window.
 * 
 * # Arguments
 * 
 * * `app` - A handle to the Tauri application instance.
 */
async disableBlur() : Promise<void> {
    await TAURI_INVOKE("disable_blur");
},
/**
 * Resets the encounter.
 * 
 * # Arguments
 * 
 * * `state_manager` - The state manager.
 * 
 * # Returns
 * 
 * * `Result<(), String>` - An empty result.
 */
async resetEncounter() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("reset_encounter") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Toggles pausing the encounter.
 * 
 * # Arguments
 * 
 * * `state_manager` - The state manager.
 * 
 * # Returns
 * 
 * * `Result<(), String>` - An empty result.
 */
async togglePauseEncounter() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("toggle_pause_encounter") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Sets whether to only show boss DPS.
 * 
 * # Arguments
 * 
 * * `enabled` - Whether to enable boss-only DPS.
 * * `state_manager` - The state manager.
 * 
 * # Returns
 * 
 * * `Result<(), String>` - An empty result.
 */
async setBossOnlyDps(enabled: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("set_boss_only_dps", { enabled }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Enables or disables dungeon segment tracking.
 */
async setDungeonSegmentsEnabled(enabled: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("set_dungeon_segments_enabled", { enabled }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Sets the event update rate in milliseconds.
 * 
 * # Arguments
 * 
 * * `rate_ms` - The update rate in milliseconds (clamped to 50-2000ms range).
 * * `state_manager` - The state manager.
 * 
 * # Returns
 * 
 * * `Result<(), String>` - An empty result.
 */
async setEventUpdateRateMs(rateMs: number) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("set_event_update_rate_ms", { rateMs }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Returns the current dungeon log snapshot for the frontend.
 */
async getDungeonLog() : Promise<Result<DungeonLog, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_dungeon_log") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Sets the monitored skill list for skill CD updates.
 */
async setMonitoredSkills(skillLevelIds: number[]) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("set_monitored_skills", { skillLevelIds }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Sets the monitored buff list for buff updates.
 */
async setMonitoredBuffs(buffBaseIds: number[]) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("set_monitored_buffs", { buffBaseIds }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Returns all buffs that have a sprite image available.
 */
async getAvailableBuffs() : Promise<Result<BuffDefinition[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_available_buffs") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Returns display names for requested buff ids, including buffs without sprite images.
 */
async getBuffNames(baseIds: number[]) : Promise<Result<BuffNameInfo[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_buff_names", { baseIds }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Searches buffs by name and returns matching entries, including no-icon buffs.
 */
async searchBuffsByName(keyword: string, limit: number | null) : Promise<Result<BuffNameInfo[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("search_buffs_by_name", { keyword, limit }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async setMonitorAllBuff(monitorAllBuff: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("set_monitor_all_buff", { monitorAllBuff }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async setBuffPriority(priorityBuffIds: number[]) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("set_buff_priority", { priorityBuffIds }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Gets a list of recent encounters.
 * 
 * # Arguments
 * 
 * * `limit` - The maximum number of encounters to return.
 * * `offset` - The number of encounters to skip.
 * 
 * # Returns
 * 
 * * `Result<RecentEncountersResult, String>` - A list of recent encounters.
 */
async getRecentEncounters(limit: number, offset: number) : Promise<Result<RecentEncountersResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_recent_encounters", { limit, offset }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Gets a list of unique scene names.
 * 
 * # Returns
 * 
 * * `Result<SceneNamesResult, String>` - A list of unique scene names.
 */
async getUniqueSceneNames() : Promise<Result<SceneNamesResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_unique_scene_names") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Gets a list of unique boss names.
 * 
 * # Returns
 * 
 * * `Result<BossNamesResult, String>` - A list of unique boss names.
 */
async getUniqueBossNames() : Promise<Result<BossNamesResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_unique_boss_names") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Gets a list of player names filtered by a prefix.
 * 
 * This will return up to 5 matching player names (to keep the UI responsive).
 * 
 * # Arguments
 * 
 * * `prefix` - The prefix to filter by.
 * 
 * # Returns
 * 
 * * `Result<PlayerNamesResult, String>` - A list of player names.
 */
async getPlayerNamesFiltered(prefix: string) : Promise<Result<PlayerNamesResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_player_names_filtered", { prefix }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Gets a list of recent encounters filtered by the given criteria.
 * 
 * # Arguments
 * 
 * * `limit` - The maximum number of encounters to return.
 * * `offset` - The number of encounters to skip.
 * * `filters` - The filters to apply.
 * 
 * # Returns
 * 
 * * `Result<RecentEncountersResult, String>` - A list of recent encounters.
 */
async getRecentEncountersFiltered(limit: number, offset: number, filters: EncounterFiltersDto | null) : Promise<Result<RecentEncountersResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_recent_encounters_filtered", { limit, offset, filters }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Gets an encounter by its ID.
 * 
 * # Arguments
 * 
 * * `encounter_id` - The ID of the encounter.
 * 
 * # Returns
 * 
 * * `Result<EncounterSummaryDto, String>` - The encounter summary.
 */
async getEncounterById(encounterId: number) : Promise<Result<EncounterSummaryDto, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_encounter_by_id", { encounterId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Gets raw actor entities for a historical encounter.
 */
async getEncounterEntitiesRaw(encounterId: number) : Promise<Result<HistoryEntityData[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_encounter_entities_raw", { encounterId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Deletes an encounter by its ID.
 * 
 * # Arguments
 * 
 * * `encounter_id` - The ID of the encounter to delete.
 * 
 * # Returns
 * 
 * * `Result<(), String>` - An empty result indicating success or failure.
 */
async deleteEncounter(encounterId: number) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("delete_encounter", { encounterId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Deletes multiple encounters by ID.
 * 
 * # Arguments
 * 
 * * `ids` - The IDs of the encounters to delete.
 * 
 * # Returns
 * 
 * * `Result<(), String>` - An empty result indicating success or failure.
 */
async deleteEncounters(ids: number[]) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("delete_encounters", { ids }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Toggles the favorite status of an encounter.
 * 
 * # Arguments
 * 
 * * `id` - The ID of the encounter.
 * * `is_favorite` - The new favorite status.
 * 
 * # Returns
 * 
 * * `Result<(), String>` - An empty result indicating success or failure.
 */
async toggleFavoriteEncounter(id: number, isFavorite: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("toggle_favorite_encounter", { id, isFavorite }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * A Tauri command to get a list of recent players.
 * 
 * # Arguments
 * 
 * * `limit` - The maximum number of players to return.
 * 
 * # Returns
 * 
 * * `Result<Vec<(i64, String)>, String>` - A list of recent players.
 */
async getRecentPlayersCommand(limit: number) : Promise<Result<([number, string])[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_recent_players_command", { limit }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * A Tauri command to get the name of a player by their UID.
 * 
 * # Arguments
 * 
 * * `uid` - The UID of the player.
 * 
 * # Returns
 * 
 * * `Result<Option<String>, String>` - The name of the player, or `None` if not found.
 */
async getPlayerNameCommand(uid: number) : Promise<Result<string | null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_player_name_command", { uid }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async savePacketCaptureSettings(method: string, npcapDevice: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("save_packet_capture_settings", { method, npcapDevice }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getNetworkDevices() : Promise<Result<Device[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_network_devices") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async checkNpcapStatus() : Promise<boolean> {
    return await TAURI_INVOKE("check_npcap_status");
},
async openLogDir() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("open_log_dir") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Creates a debug ZIP containing the most recent application log file and returns the path.
 * 
 * If `destination_path` is provided, the ZIP is written there. Otherwise it is created
 * in the app log directory.
 */
async createDiagnosticsBundle(destinationPath: string | null) : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("create_diagnostics_bundle", { destinationPath }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async checkGpuSupport() : Promise<GpuSupport> {
    return await TAURI_INVOKE("check_gpu_support");
},
async getLatestModules() : Promise<Result<ModuleInfo[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_latest_modules") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async optimizeLatestModules(targetAttributes: number[], excludeAttributes: number[], minAttrRequirements: Partial<{ [key in number]: number }> | null, useGpu: boolean | null) : Promise<Result<ModuleSolution[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("optimize_latest_modules", { targetAttributes, excludeAttributes, minAttrRequirements, useGpu }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async greedyOptimizeModules(modules: ModuleInfo[], targetAttributes: number[], excludeAttributes: number[], maxSolutions: number | null, maxAttemptsMultiplier: number | null, localSearchIterations: number | null) : Promise<Result<ModuleSolution[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("greedy_optimize_modules", { modules, targetAttributes, excludeAttributes, maxSolutions, maxAttemptsMultiplier, localSearchIterations }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
}
}

/** user-defined events **/



/** user-defined constants **/



/** user-defined types **/

/**
 * The result of a query for boss names.
 */
export type BossNamesResult = { 
/**
 * A list of boss names.
 */
names: string[] }
/**
 * A summary of a boss.
 */
export type BossSummaryDto = { 
/**
 * The name of the monster.
 */
monsterName: string; 
/**
 * The maximum HP of the monster.
 */
maxHp: number | null; 
/**
 * Whether the boss was defeated.
 */
isDefeated: boolean }
export type BuffDefinition = { baseId: number; name: string; spriteFile: string; searchKeywords: string[] }
export type BuffNameInfo = { baseId: number; name: string; hasSpriteFile: boolean }
export type CombatState = "idle" | "inCombat"
/**
 * Discrete damage occurrence stored on a segment.
 */
export type DamageEvent = { timestampMs: number; attackerId: number; targetId: number; targetName: string | null; targetMonsterTypeId: number | null; amount: number; isBossTarget: boolean; isKillingBlow: boolean }
export type Device = { name: string; description: string | null }
/**
 * Master container for dungeon segments within a scene.
 */
export type DungeonLog = { sceneId: number | null; sceneName: string | null; combatState: CombatState; segments: Segment[] }
/**
 * Filters for querying encounters.
 */
export type EncounterFiltersDto = { 
/**
 * A list of boss names to filter by.
 */
bossNames: string[] | null; 
/**
 * A list of encounter names to filter by.
 */
encounterNames: string[] | null; 
/**
 * A player name to filter by.
 */
playerName: string | null; 
/**
 * A list of player names to filter by.
 */
playerNames: string[] | null; 
/**
 * The start date to filter by in milliseconds since the Unix epoch.
 */
dateFromMs: number | null; 
/**
 * The end date to filter by in milliseconds since the Unix epoch.
 */
dateToMs: number | null; 
/**
 * Whether to filter by favorite encounters.
 */
isFavorite: boolean | null }
/**
 * A summary of an encounter.
 */
export type EncounterSummaryDto = { 
/**
 * The ID of the encounter.
 */
id: number; 
/**
 * The start time of the encounter in milliseconds since the Unix epoch.
 */
startedAtMs: number; 
/**
 * The end time of the encounter in milliseconds since the Unix epoch.
 */
endedAtMs: number | null; 
/**
 * The total damage dealt in the encounter.
 */
totalDmg: number; 
/**
 * The total healing done in the encounter.
 */
totalHeal: number; 
/**
 * The ID of the scene where the encounter took place.
 */
sceneId: number | null; 
/**
 * The name of the scene where the encounter took place.
 */
sceneName: string | null; 
/**
 * The duration of the encounter in seconds.
 */
duration: number; 
/**
 * The UID of the local player for this encounter.
 */
localPlayerId: number | null; 
/**
 * A list of bosses in the encounter.
 */
bosses: BossSummaryDto[]; 
/**
 * The encounter ID on the remote website/server after successful upload.
 */
remoteEncounterId: number | null; 
/**
 * Whether the encounter is favorited.
 */
isFavorite: boolean }
export type GpuSupport = { cuda_available: boolean; opencl_available: boolean }
export type HistoryEntityData = { uid: number; name: string; classId: number; classSpec: number; className: string; classSpecName: string; abilityScore: number; damage: RawCombatStats; damageBossOnly: RawCombatStats; healing: RawCombatStats; taken: RawCombatStats; activeDmgTimeMs: number; dmgSkills: Partial<{ [key in number]: RawSkillStats }>; healSkills: Partial<{ [key in number]: RawSkillStats }>; takenSkills: Partial<{ [key in number]: RawSkillStats }>; dmgPerTarget: PerTargetStats[]; healPerTarget: PerTargetStats[] }
export type ModuleInfo = { name: string; config_id: number; uuid: number; quality: number; parts: ModulePart[] }
export type ModulePart = { id: number; name: string; value: number }
export type ModuleSolution = { modules: ModuleInfo[]; score: number; attr_breakdown: Partial<{ [key in string]: number }> }
export type PerTargetStats = { targetUid: number; targetName: string; totalValue: number; damage: RawCombatStats; skills: Partial<{ [key in number]: RawSkillStats }> }
/**
 * The result of a query for player names.
 */
export type PlayerNamesResult = { 
/**
 * A list of player names.
 */
names: string[] }
export type RawCombatStats = { total: number; hits: number; critHits: number; critTotal: number; luckyHits: number; luckyTotal: number }
export type RawSkillStats = { totalValue: number; hits: number; critHits: number; critTotalValue: number; luckyHits: number; luckyTotalValue: number }
/**
 * The result of a query for recent encounters.
 */
export type RecentEncountersResult = { 
/**
 * The rows of encounter summaries.
 */
rows: EncounterSummaryDto[]; 
/**
 * The total number of encounters.
 */
totalCount: number }
/**
 * The result of a query for scene names.
 */
export type SceneNamesResult = { 
/**
 * A list of scene names.
 */
names: string[] }
/**
 * Represents an individual combat segment (boss or trash).
 */
export type Segment = { id: number; segmentType: SegmentType; 
/**
 * Primary boss entity ID (first one seen) - kept for backwards compatibility
 */
bossEntityId: number | null; bossMonsterTypeId: number | null; bossName: string | null; startedAtMs: number; endedAtMs: number | null; totalDamage: number; hitCount: number; events: DamageEvent[] }
export type SegmentType = "boss" | "trash"

/** tauri-specta globals **/

import {
	invoke as TAURI_INVOKE,
	Channel as TAURI_CHANNEL,
} from "@tauri-apps/api/core";
import * as TAURI_API_EVENT from "@tauri-apps/api/event";
import { type WebviewWindow as __WebviewWindow__ } from "@tauri-apps/api/webviewWindow";

type __EventObj__<T> = {
	listen: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.listen<T>>;
	once: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.once<T>>;
	emit: null extends T
		? (payload?: T) => ReturnType<typeof TAURI_API_EVENT.emit>
		: (payload: T) => ReturnType<typeof TAURI_API_EVENT.emit>;
};

export type Result<T, E> =
	| { status: "ok"; data: T }
	| { status: "error"; error: E };

function __makeEvents__<T extends Record<string, any>>(
	mappings: Record<keyof T, string>,
) {
	return new Proxy(
		{} as unknown as {
			[K in keyof T]: __EventObj__<T[K]> & {
				(handle: __WebviewWindow__): __EventObj__<T[K]>;
			};
		},
		{
			get: (_, event) => {
				const name = mappings[event as keyof T];

				return new Proxy((() => {}) as any, {
					apply: (_, __, [window]: [__WebviewWindow__]) => ({
						listen: (arg: any) => window.listen(name, arg),
						once: (arg: any) => window.once(name, arg),
						emit: (arg: any) => window.emit(name, arg),
					}),
					get: (_, command: keyof __EventObj__<any>) => {
						switch (command) {
							case "listen":
								return (arg: any) => TAURI_API_EVENT.listen(name, arg);
							case "once":
								return (arg: any) => TAURI_API_EVENT.once(name, arg);
							case "emit":
								return (arg: any) => TAURI_API_EVENT.emit(name, arg);
						}
					},
				});
			},
		},
	);
}
